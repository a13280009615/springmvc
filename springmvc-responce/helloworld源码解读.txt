
1 所有的请求过来经过DispatcherServlet
2 调用了doDispatch 方法进行处理
    1) getHandler():根据当前请求地址在handlerMapping找到这个请求的映射信息 获取到这个请求的目标处理器类
      返回值 HandlerExecutionChain就是一个处理器执行链
        getHandler()内部做了一个for循环遍历当前的handlerMappings
        handlerMapping 处理器映射器 他里面保存了每一个处理器能处理那些请求的映射信息是从
        handlerMap中就是保存的 路径 和处理器的一一对应  ioc容器启动创建处理器对象的时候扫描每个处理器
        都能处理哪个请求，保存在HandlerMapping的handlerMap属性中 下一次请求过来就直接来看
        哪个HandlerMapping中有这个请求映射 注解是使用的 DefaultAnnotationHandlerMapping
        spring 3.0 使用的是BeanNameUrlHandlerMapping

    2) getHandlerAdapter() 根据当前处理器类找到当前类的HandlerAdapter 处理器适配器
   返回值是一个HandlerAdapter  处理器适配器    
   内部操作：
         遍历所有的处理器适配器 (注解是使用AnnotationMethodHandlerAdapter 该适配器能能解析注解方法的适配器)
         HandlerAdapter.supports(); 判断这个处理器 是否 是 HandlerAdapter 的实例
         HandlerAdapter.supports()内部操作：拿到方法的解析器 解析   handlerMethods判断这个处理器中是否有这个方法
        不为空才会返回这个AnnotationMethodHandlerAdapter 这个对象
    
    3) 使用刚才获取到的适配器执行目标方法AnnotationMethodHandlerAdapter执行方法
     ha.handle(processedRequest, response, mappedHandler.getHandler());
    4) 目标方法执行之后会返回一个ModelAndView对象
    5) 根据ModelAndView的信息转发到具体的页面 并可以在请求域中获取ModelAndView中的模型数据



protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;
		boolean multipartRequestParsed = false;

		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

		try {
			ModelAndView mv = null;
			Exception dispatchException = null;

			try {
			    //检查当前请求是文件上传请求
				processedRequest = checkMultipart(request);
				multipartRequestParsed = (processedRequest != request);

				// Determine handler for the current request. 确定当前请求处理程序。
				mappedHandler的就是一个HandlerExecutionChain处理器执行链
				mappedHandler = getHandler(processedRequest);
				//如果没有找个这个处理器 能处理这个请求 就抛异常
				if (mappedHandler == null || mappedHandler.getHandler() == null) {
					noHandlerFound(processedRequest, response);
					return;
				}

				// Determine handler adapter for the current request.
				确定当前请求处理程序适配器是一个AnnotationMethodHandlerAdapter mappedHandler.getHandler() 就是这个controler标注的类
                                                                拿到适配器才能执行目标方法
				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

				// Process last-modified header, if supported by the handler.
				 获取请求方式
				String method = request.getMethod();
				boolean isGet = "GET".equals(method);
				if (isGet || "HEAD".equals(method)) {
					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
					if (logger.isDebugEnabled()) {
						logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified);
					}
					if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
						return;
					}
				}

				if (!mappedHandler.applyPreHandle(processedRequest, response)) {
					return;
				}

				// 实际调用处理程序。处理器的方法被调用
				是用适配器执行目标方法 将目标方法的返回值作为视图名 设置保存在ModelAndView中
				目标方法无论怎么写 最终适配器执行完成以后都会将执行后的信息封装成ModelAndView
				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

				if (asyncManager.isConcurrentHandlingStarted()) {
					return;
				}
                //如果没有一个视图名 设置一个默认的视图名
				applyDefaultViewName(processedRequest, mv);
				mappedHandler.applyPostHandle(processedRequest, response, mv);
			}
			catch (Exception ex) {
				dispatchException = ex;
			}
			catch (Throwable err) {
				// As of 4.3, we're processing Errors thrown from handler methods as well,
				// making them available for @ExceptionHandler methods and other scenarios.
				dispatchException = new NestedServletException("Handler dispatch failed", err);
			}

			//转发到目标页面  根据方法最终执行完成后 封装的ModelAndView转发到对应页面
			而且ModelAndView的数据可以从请求域中获取
			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		}
		catch (Exception ex) {
			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
		}
		catch (Throwable err) {
			triggerAfterCompletion(processedRequest, response, mappedHandler,
					new NestedServletException("Handler processing failed", err));
		}
		finally {
			if (asyncManager.isConcurrentHandlingStarted()) {
				// Instead of postHandle and afterCompletion
				if (mappedHandler != null) {
					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
				}
			}
			else {
				// Clean up any resources used by a multipart request.
				if (multipartRequestParsed) {
					cleanupMultipart(processedRequest);
				}
			}
		}
	}

------------------------------------------------------------------------------------------------------------------------
DispacherServlet 中有几个引用类型的属性： springMVC的9大组件
springMVC在工作的时候 关键位置都是由这些组件完成的

共同点  九大组件全部都是接口 接口就是规范  提供了非常强大的扩展性

组件的初始化: 去容器中找这个组件 如果没有找到就用默认的配置
  
  有些组件在容器中是使用类型找的，有些组件是使用id找

	/** 多部件解析器      文件上传  */
	private MultipartResolver multipartResolver;

	/** 区域信息解析器  国际化 */
	private LocaleResolver localeResolver;

	/**主题解析器   强大的主题效果更换 */
	private ThemeResolver themeResolver;

	/** 处理器映射器   */
	private List<HandlerMapping> handlerMappings;

	/** 处理器适配器 */
	private List<HandlerAdapter> handlerAdapters;

	/** springMVC处理器异常解析器   处理强大的异常解析功能 */
	private List<HandlerExceptionResolver> handlerExceptionResolvers;

	/** 请求地址转换器 */
	private RequestToViewNameTranslator viewNameTranslator;

	/** spring MVC 中允许重定向携带数据的功能 */
	private FlashMapManager flashMapManager;

	/** 视图解析器 */
	private List<ViewResolver> viewResolvers;

   重写了 springIOC 的  onRefresh方法

@Override
	protected void onRefresh(ApplicationContext context) {
                               //加载了 springmvc的9大内置对象
		initStrategies(context);
	}



protected void initStrategies(ApplicationContext context) {
		initMultipartResolver(context);
		initLocaleResolver(context);
		initThemeResolver(context);
		initHandlerMappings(context);
		initHandlerAdapters(context);
		initHandlerExceptionResolvers(context);
		initRequestToViewNameTranslator(context);
		initViewResolvers(context);
		initFlashMapManager(context);
	}